// ---------------------------------------------------------------------------
// 03_04 1주차 1일 (화요일) <OT - 1시간 30분 수업함..ㅠ>
// ---------------------------------------------------------------------------
// 게임에 대한 소개...
// MMOG - 대규모 다중 사용자 온라인 게임
// 
// ---------------------------------------------------------------------------
// 포볼 : IOCP, DB, ASIO, 동접 5000명 위주로 만들어 두자.
// 면접 : 비동기, I/O,IOCP, 성능 측정, 최적화 관련해서 질문 많이 한다.
// ---------------------------------------------------------------------------
// 
// MMO 게임 - 일종의 메타버스, 대한민국 게임산업의 중심, 많은 사람들이 모여서 생활하고 투쟁하는 가상공간.
// 핵심 - 서버 기술
// 
// 좋은 게임서버
// 1. 안정성
//		- 서버 다운이 없어야 한다. ( 1/2법칙 : 초창기에는 서버다운 한번에 고객의 반이 그만둔다.)
// 
// 2. 보안
//		- 해킹, 복사, 오토
// 
// 3. 성능
//		- 동접자 수/서버 비용 
//		- 동접자 수/월드 ( 게임의 재미에서 큰영향, 시골 서버와 도시 서버 )
//		- HotSpot ( 이벤트, 공성전, 길드전, 상대 도시 레이드 )
//
// 과제 나옴
// 
// ---------------------------------------------------------------------------
// 03_06 1주차 2일 (목요일)  <오늘부터 수업 시작>
// ---------------------------------------------------------------------------
// 
// 게임서버를 위한 하드웨어와 소프트웨어
// 
// MMO 게임서버 특징
//	1. 고사양을 필요로 한다.
//		- 저사양 PC보다 고사양 PC로 더 많은 동접을 받을 수 있다.
//		- 가능한 최고 사양의 PC를 사용해서 동접을 올린다.
//		- 동접이 올라간다 -> 많은 사용자가 몰려온다 -> 많은 수익을 올린다.
// 
//	2. 고사양 PC(서버 PC)
//		- CPU : 싱글코어로는 동접 1000도 어렵다.
//				멀티 코어 사용 -> 멀티쓰레딩 필요.
//				멀티 CPU 사용.
//		- Memory : 128GB 이상 필요.
//		- Network : 복수개의 NetWork Port 필요.
//		- 보조 기억 장치 : 상관 없음. ( 상관 없어야 함. )
// 
// 
// 게임서버 하드웨어
//	1. HW( 하드웨어 )만 좋으면 되는건가?
//		- HW를 100%활용할 수 있는 프로그래밍이 필요.
//		- 특히 Core/멀티 CPU , 네트워크 프로그래밍.
// 
//	2. 하드웨어 지식이 필요한 이유
//		- 서버에 걸리는 과부하가 많기 때문에 하드웨어의 성능을 최대한 끌어내는 프로그래밍이 필요.
//		- 하드웨어가 어떻게 성능에 영향을 미치는지 알아야 한다.
//
//	3. 중요 하드웨어
//		- CPU , Memory, Network
// 
//	4. CPU
//		- X86 계열이 대세. ( ARM은 사용불가. )
//		- AMD 와 Intel의 2가지 계열이 있다. ( 서버용 CPU가 따로 존재 )
//		- 64bit, Multi-core
//		- 코어개수, 클럭 속도와 Cache 크기, 메모리 Bus대역폭이 중요.
//		- 서버용 CPU는 멀티프로세서를 지원. ( Cache 동기화 지원. ) <- 일반 CPU랑 가장 큰 차이점!!!
//		- 서버용 CPU는 서로간의 데이터 전송 전용 통로를 제공.
//		- 메모리 채널 증가 ( 8개 까지 ) 
//		- CPU의 개수가 많아질 수록 과거방식에서는 성능의 한계
// 
//	5. Memory 
//		- 서버가 요구하는 용량을 제공하면 된다.
//		- 일반적인 메모리가 아니라 Error수정기능이 있는 특수 메모리이다. ( 서버용 )
// 
//	6. Network
//		- 10G 까지 발전.
//		- 한 서버에 여러개의 네트워크 카드를 꽂아서 사용하기도 한다. ( 확장 버스의 대역폭을 고려해야 함. )
//				PCI : 133MB/s
//				PCI-Express 2.0 : 500MB/s
//		- 속도가 더 필요하면 Infiniband 사용 ( 게임 업계에서는 사용X )
// 
// 
// 게임서버 하드웨어 ( CPU )
//	1. 64비트 이슈
//		- OS와 Compiler도 64비트 버전을 사용해야 한다.
//		- 기존의 32비트는 최대 4GB의 메모리 밖에 쓸수 없었기 때문에 서버 용량에 제한이 많았다.
//		- Linux만 long이 64비트가 된다. ( 윈도우에서는 long은 32비트이다. )
// 
//	2. 멀티 프로세서
//		- SMP 
//		- 빠른 네트워크 응답속도와 처리 속도 개선을 위해
// 
// 3. 멀티코어
//		- 발열에 막힌 CPU의 성능향상 제한을 극복하기 위한 궁여 지책.
//		- 앞으로도 계속 core의 개수가 늘어날 예정.
// 
//	4. 멀티 프로세서와 멀티코어의 차이점
//		- SW적으로는 차이가 X ( 프로그램적으로는 똑같다. )
//		- HW적으로는 메모리 접근시 성능 차이가 존재. ( 똑같은 변수를 읽는데 각각의 CPU의 읽는 속도의 차이가 있다. ) / Cache까지 오는게 속도가 다른거지 오면 똑같다.
// 
//	5. CPU 발전의 트렌드
//		- 클럭 속도 증가( ~ 2000년 까지)
//				물리법칙의 한계에 부딪침. ( 더이상 늘릴수 없음. ) / 물리법칙 : 양자역학
//		- Clock당 수행되는 명령어의 개수 증가. (IPC)
//				아키택쳐의 개선
//				한계 효용의 법칙으로인해 한계에 부딪침.
//		- 코어 개수 증가 ( 2005년 ~ )
//				현재의 방식 ( 현재 128코어 까지 나옴. 앞으로 계속 늘어날 예정. )
//				발열로 인한 클럿속도 향상의 한계가 주 원인. 
//		
//	6. 파이프 라인의 발전
//		- 파이프라인이 무효화 되지 않는 한 프로그램의 실행속도는 메모리 Read에 종속됨. ( 명령어가 더 많아도 메모리 Read가 적으면 더 빠름. )
// 
//	7. SIMD 명령어의 발전
//		- 하나의 명령어로 여러개의 실수를 동시에 연산 
// 
//	8. Pipeline의 고도화에 따른 주의
//		- 파이프 라인을 리셋 시키면 손해가 너무 크다. ( Pentium 4의 경우 31단계 )
//		- 리셋의 원인
//				시스템 콜
//				분기 예측 오류
//		- Stall의 원인 ( Cache read miss )
//		- 대책 ( 시스템 콜을 될수 있으면 하지 말것, if랑 switch등을 자제 )
// 
//	9. CACHE
//		- Cache가 큰 CPU일 수록 속도가 빠르다.
// 
//	10. 게임서버 하드웨어 CPU 의 Tip
//		- 같이 쓰이게 되는 데이터는 묶어 놓는다.
//		- 루프 안에서 사용하는 데이터는 캐쉬에 다 올라올 수 있도록 한다.
//		- int 대신에 short나 char을 사용한다.
// 
//	11. 멀티 프로세스 프로그래밍
//		- 잘하면 N배 성능향상, 못하면 성능하락.
//		- Lock을 줄여라. ( Lock이 성능하락의 주범. )
//		- Cache Thrasing에 주의.
// 
// 
// 게임서버 운영체제
//	1. 서버용 운영체제 종류
//		- Unix 계열
//				리눅스 / 가격이 저렴 ( 0원 ) / 유지보수 관리가 어렵다 ( 일일히 손으로 다 관리를 해야하기에 )
//		- Windows 계열
//				서버용 윈도우 ( Windows 2022 등 ) / 비싸다 / 유지보수 관리가 비교적 쉽다
// 
// 
// 프로그램 최적화
//	1. 꼭 필요한 일만 하기
//	2. 좋은 알고리즘 사용
//	3. 메모리 복사 줄이기
//	4. HW영향 고려
//	5. 멀티쓰레드 프로그래밍
// 
// 
// --------------------------- < 추가 설명 들> --------------------------------
// GPU가 일종의 슬레그 이다?
// GPU는 명령을 받고 실행만 하기 때문?
// 
// 우리의 pc는 계속해서 intrrupt 되고 있다 ( 키보드 ,마우스, ... 등등 )
// 
// ---------------------------------------------------------------------------